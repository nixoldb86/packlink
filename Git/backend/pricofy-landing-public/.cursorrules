# Cursor AI Rules Configuration
# These rules guide the AI assistant's behavior when working on code

## File Operations
- Don't ask for confirmation on file edits unless the file is outside the project scope
- Always prefer editing existing files over creating new ones unless explicitly required

## Code Quality Standards

### Documentation
- Code must be well documented, including:
  - Class documentation
  - Function/method documentation
  - Variable documentation with meaningful descriptions
  - Internal line comments explaining complex logic
- Use language-specific documentation standards:
  - Javadoc for Java
  - JSDoc for JavaScript/TypeScript
  - Docstrings for Python
  - XML comments for C#
- Always write documentation and comments in English

### Code Structure
- Follow a divide-and-conquer approach
- Keep functions reasonably sized and focused on a single responsibility
- Break down complex functions into smaller, manageable units
- Maintain clear separation of concerns
- Use design patterns appropriately

### Code Quality Principles
- Follow SonarQube quality principles:
  - Avoid code duplication
  - Maintain low cyclomatic complexity
  - Keep function/method length reasonable
  - Avoid deep nesting
  - Follow SOLID principles
- Never provide "quick and dirty" solutions
- Always prioritize maintainability and readability
- Write production-ready code, not prototypes

### Error Handling and Logging
- Implement proper error and exception management
- Ensure all errors are well controlled and properly propagated
- Include appropriate logging at different levels:
  - INFO for important state changes
  - WARN for recoverable issues
  - ERROR for failures
  - DEBUG for troubleshooting information
- Use structured logging when available
- Include contextual information in log messages
- Log exceptions with full stack traces when appropriate
- Never swallow exceptions silently

### Naming Conventions
- Never use short or abbreviated names for variables or methods
- All naming must be descriptive and self-explanatory
- Use meaningful names that express intent
- Follow language-specific naming conventions:
  - camelCase for Java/JavaScript methods and variables
  - PascalCase for classes
  - snake_case for Python
  - UPPER_SNAKE_CASE for constants
- Always use English for all code elements (variables, functions, classes, etc.)

## Architecture Principles

### Hexagonal Architecture (Ports & Adapters)
- Apply hexagonal architecture when it makes sense for the project
- Structure code in clear layers:
  - **Domain Layer**: Business logic, entities, value objects, domain services
    - Must be framework-agnostic and have no external dependencies
    - Contains the core business rules and invariants
  - **Application Layer**: Use cases, application services, orchestration
    - Coordinates domain objects to fulfill use cases
    - Defines ports (interfaces) for external dependencies
  - **Infrastructure Layer**: Adapters, implementations, frameworks
    - Implements the ports defined in the application layer
    - Contains database repositories, external API clients, messaging, etc.
- Follow the **Dependency Rule**: Dependencies always point inward
  - Domain depends on nothing
  - Application depends only on Domain
  - Infrastructure depends on Application and Domain
- Use **Ports and Adapters**:
  - Define ports (interfaces) for all external interactions
  - Implement adapters for specific technologies
  - Keep the core domain isolated from infrastructure concerns

### Dependency Injection
- Use dependency injection to manage dependencies
- Prefer constructor injection over field injection
- Inject interfaces, not concrete implementations
- Configure DI containers at the composition root
- Avoid service locator pattern
- Make dependencies explicit and testable

### Domain-Driven Design (when applicable)
- Use ubiquitous language in code that matches business terminology
- Define clear bounded contexts
- Use aggregates to maintain consistency boundaries
- Implement domain events for cross-aggregate communication
- Keep domain models rich with behavior, not anemic
- Use value objects for concepts without identity
- Implement repositories only for aggregate roots

### SOLID Principles (detailed)
- **Single Responsibility**: Each class should have one reason to change
- **Open/Closed**: Open for extension, closed for modification
- **Liskov Substitution**: Subtypes must be substitutable for their base types
- **Interface Segregation**: Many specific interfaces are better than one general-purpose interface
- **Dependency Inversion**: Depend on abstractions, not concretions

## Testing Strategy

### Test Pyramid
- Write tests at multiple levels:
  - **Unit Tests**: Fast, isolated, test single components
    - Mock external dependencies
    - Focus on business logic and domain rules
    - Aim for high coverage of domain layer
  - **Integration Tests**: Test interaction between components
    - Test repository implementations with real databases (test containers)
    - Test external API integrations
    - Verify adapter implementations
  - **End-to-End Tests**: Test complete user workflows
    - Use sparingly for critical paths
    - Test through the actual entry points (API, UI)

### Testing Best Practices
- Write tests first when practicing TDD
- Follow the Arrange-Act-Assert (AAA) pattern
- One assertion per test when possible
- Use descriptive test names that explain the scenario
- Keep tests independent and isolated
- Use test data builders or fixtures for complex object creation
- Mock only external dependencies, not internal domain logic
- Consider property-based testing for complex logic
- Use architecture tests (ArchUnit, NetArchTest) to enforce architectural rules

### Test Coverage
- Aim for high coverage in the domain layer (80%+)
- Focus on testing behavior, not implementation details
- Don't obsess over 100% coverage, focus on critical paths
- Use coverage tools to identify untested code paths

## Security Principles

### Input Validation and Sanitization
- Validate all input at the boundaries (API controllers, message handlers)
- Use strong typing to prevent invalid states
- Sanitize input to prevent injection attacks
- Implement validation logic in the domain layer for business rules
- Use validation libraries and frameworks (Bean Validation, Joi, etc.)
- Never trust client-side validation alone

### Authentication and Authorization
- Implement authentication at the infrastructure/adapter level
- Define authorization rules in the application/domain layer
- Use role-based or policy-based access control
- Apply the principle of least privilege
- Validate permissions before executing use cases
- Never expose sensitive data in logs or error messages

### Security Best Practices
- Follow OWASP Top 10 guidelines
- Never store secrets in code or version control
- Use environment variables or secret management services
- Implement proper session management
- Use HTTPS for all communications
- Apply rate limiting and throttling
- Implement audit logging for sensitive operations
- Keep dependencies up to date and scan for vulnerabilities
- Use parameterized queries to prevent SQL injection
- Implement proper CORS policies
- Hash and salt passwords properly (bcrypt, Argon2)

## Performance and Scalability

### When to Optimize
- Profile before optimizing
- Focus on algorithmic complexity first
- Optimize bottlenecks identified through metrics
- Don't sacrifice readability for premature optimization
- Consider performance requirements from the start for high-traffic systems

### Performance Best Practices
- Use appropriate data structures and algorithms
- Implement caching strategically:
  - Cache expensive computations
  - Use cache invalidation strategies
  - Consider distributed caching for scalability
- Optimize database queries:
  - Use indexes appropriately
  - Avoid N+1 queries
  - Use pagination for large result sets
  - Consider read replicas for read-heavy workloads
- Implement asynchronous processing for long-running operations
- Use bulk operations instead of loops for batch processing
- Consider connection pooling for database and external services

### Scalability Considerations
- Design for horizontal scaling when possible
- Use stateless services
- Implement idempotent operations
- Use message queues for decoupling and load leveling
- Consider eventual consistency where strong consistency isn't required
- Implement circuit breakers for external service calls
- Use database migrations for schema changes

## API Design (when applicable)

### RESTful API Principles
- Use HTTP methods correctly (GET, POST, PUT, PATCH, DELETE)
- Use proper HTTP status codes
- Design resource-oriented endpoints
- Use plural nouns for resource collections
- Implement proper error responses with meaningful messages
- Use JSON as the default format unless there's a specific reason otherwise

### API Best Practices
- Implement API versioning (URL path or header-based)
- Provide comprehensive API documentation (OpenAPI/Swagger)
- Use consistent naming conventions across endpoints
- Implement pagination for list endpoints
- Support filtering, sorting, and searching where appropriate
- Use HATEOAS when it adds value
- Implement rate limiting
- Provide clear validation error messages
- Use ETags for caching when appropriate
- Implement proper CORS configuration

### GraphQL (when applicable)
- Design schema-first
- Implement proper error handling
- Avoid N+1 queries with DataLoader
- Implement proper authorization at the resolver level
- Provide clear schema documentation

## Language Requirements
- All code, comments, documentation, logs, and commit messages must be in English
- Exception messages and user-facing text should also be in English unless specifically required otherwise

## Version Control

### Git Workflow Rules
- **NEVER perform a commit or push to git without asking first**
- **NEVER skip hooks (--no-verify, --no-gpg-sign, etc.) unless explicitly requested**
- **NEVER run destructive/irreversible git commands (force push, hard reset, etc.) unless explicitly requested**
- **NEVER force push to main/master branches** - warn the user if they request it
- Always provide clear commit messages that explain the changes
- Follow conventional commit format when appropriate

### Commit Message Guidelines
- Use conventional commits format: `type(scope): description`
- Types: feat, fix, docs, style, refactor, test, chore
- Keep the subject line under 50 characters
- Use imperative mood ("add feature" not "added feature")
- Provide body with detailed explanation when needed
- Reference issue numbers when applicable

## Code Generation Philosophy
- Focus on writing maintainable, scalable, and testable code
- Consider edge cases and potential failure scenarios
- Implement proper input validation
- Use defensive programming techniques
- Optimize for readability first, performance second (unless performance is the explicit goal)
- Include appropriate unit tests when requested or when it makes sense
- Follow the boy scout rule: leave code better than you found it

## Technology Stack Preferences
- Use modern language features and best practices
- Leverage well-established libraries and frameworks
- Follow the principle of least surprise
- Maintain consistency with existing codebase patterns
- Prefer libraries over custom implementations for common problems
- Consider the long-term maintenance implications of technology choices

## Communication and Collaboration

### When to Proceed vs Ask
- **Proceed without asking** when:
  - Editing files within the project scope
  - Applying established patterns from the codebase
  - Implementing standard refactoring
  - Fixing obvious bugs or issues
- **Ask for clarification** when:
  - Major architectural decisions are needed
  - Requirements are ambiguous or contradictory
  - Multiple valid approaches exist with trade-offs
  - Changes could have significant side effects
  - Security or data integrity concerns arise

### Code Review Mindset
- Provide explanations for complex implementations
- Suggest improvements when obvious issues are detected
- Reference documentation or standards when making recommendations
- Consider maintainability by future developers
- Think about testability and debuggability

## Additional Guidelines
- Think in terms of business value and user needs
- Consider the total cost of ownership of solutions
- Balance pragmatism with idealism
- Know when to apply patterns and when they're overkill
- Stay updated with industry best practices
- Foster code that is easy to understand, modify, and extend
